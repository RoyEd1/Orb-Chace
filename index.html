<!DOCTYPE html>
<html>
<head>
<title>Gravity Points</title>
<style>
  body { margin: 0; overflow: hidden; background-color: #333; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
  canvas { background-color: #222; display: block; }
  .hud { position: absolute; top: 10px; left: 10px; color: #f1f1f1; font-family: sans-serif; font-size: 16px; }
  .level-display { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); color: #f1f1f1; font-family: sans-serif; font-size: 16px; }
  .hp-display { position: absolute; top: 10px; right: 10px; color: #f1f1f1; font-family: sans-serif; font-size: 16px; }
  .upgrade-dock { position: absolute; bottom: 0; left: 0; width: 100%; background-color: #444; padding: 10px; display: flex; justify-content: space-around; align-items: center; box-sizing: border-box; }
  .upgrade-button { background-color: #212121; color: #f1f1f1; border: none; padding: 10px 15px; cursor: pointer; font-family: sans-serif; font-size: 14px; border-radius: 5px; }
</style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div class="hud" id="hud">Coins: <span id="coins">0</span><br>Coin/Orb: +<span id="coinPerOrb">1</span></div>
  <div class="level-display" id="levelDisplay">Level <span id="level">1</span>-<span id="subLevel">1</span></div>
  <div class="hp-display" id="hpDisplay">HP: <span id="hp">1</span></div>
  <div class="upgrade-dock" id="upgradeDock">
    <button id="speedUpgradeBtn" class="upgrade-button">Speed (Cost: <span id="speedCost">10</span>)</button>
    <button id="sizeUpgradeBtn" class="upgrade-button">Size (Cost: <span id="sizeCost">15</span>)</button>
    <button id="levelUpBtn" class="upgrade-button">Level Up (Cost: <span id="levelUpCost">20</span>)</button>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    const hudElement = document.getElementById('hud');
    const upgradeDockElement = document.getElementById('upgradeDock');
    const hudHeight = hudElement.offsetHeight + 20; // Add some padding
    const dockHeight = upgradeDockElement.offsetHeight + 10; // Add some padding
    const playableTop = hudHeight;
    const playableBottom = height - dockHeight;

    let player = { x: width / 2, y: (playableTop + playableBottom) / 2, radius: 10, speed: 3, target: null, hp: 1, maxHp: 1 };
    let enemies = [];
    let orbs = [];
    let coins = 0;
    let level = 1;
    let subLevel = 1;
    let coinPerOrb = 1;
    let speedUpgradeCost = 10;
    let sizeUpgradeCost = 15;
    let levelUpCost = 20;
    const orbCount = 10;
    let sizeUpgradeCosts = [15]; // Track individual size upgrade costs

    function getRandomPos(radius = 0) {
      return {
        x: Math.random() * (width - 2 * radius) + radius,
        y: Math.random() * (playableBottom - playableTop - 2 * radius) + playableTop + radius
      };
    }

    function createOrb() {
      let pos = getRandomPos(8);
      // Ensure orbs don't spawn too close to the player initially
      while (Math.sqrt(Math.pow(pos.x - player.x, 2) + Math.pow(pos.y - player.y, 2)) < player.radius + 20) {
        pos = getRandomPos(8);
      }
      orbs.push({ ...pos, radius: 8 });
    }

    function createEnemy() {
      let pos = {
        x: Math.random() * (width - 24) + 12,
        y: Math.random() * (playableBottom - playableTop - 24) + playableTop + 12
      };
      enemies.push({ ...pos, radius: 12, speed: 1 + (level - 1) * 0.2 });
    }

    function resetOrbs() {
      orbs = [];
      for (let i = 0; i < orbCount; i++) {
        let pos = getRandomPos(8);
        // Ensure orbs are within the playable area and not too close to the player
        while (pos.x < 20 || pos.x > width - 20 || pos.y < playableTop + 20 || pos.y > playableBottom - 20 ||
               Math.sqrt(Math.pow(pos.x - player.x, 2) + Math.pow(pos.y - player.y, 2)) < player.radius + 20) {
          pos = getRandomPos(8);
        }
        orbs.push({ ...pos, radius: 8 });
      }
    }

    function resetGame() {
      player = { x: width / 2, y: (playableTop + playableBottom) / 2, radius: 10, speed: 3, target: null, hp: 1, maxHp: 1 };
      enemies = [];
      coins = 0;
      level = 1;
      subLevel = 1;
      coinPerOrb = 1;
      speedUpgradeCost = 10;
      sizeUpgradeCost = 15;
      levelUpCost = 20;
      sizeUpgradeCosts = [15];
      for (let i = 0; i < level; i++) {
        createEnemy();
      }
      resetOrbs();
      updateHUD();
    }

    function updateHUD() {
      document.getElementById('coins').textContent = coins;
      document.getElementById('coinPerOrb').textContent = coinPerOrb;
      document.getElementById('level').textContent = level;
      document.getElementById('subLevel').textContent = subLevel;
      document.getElementById('hp').textContent = player.hp;
      document.getElementById('speedCost').textContent = speedUpgradeCost;
      document.getElementById('sizeCost').textContent = sizeUpgradeCost;
      document.getElementById('levelUpCost').textContent = levelUpCost;
    }

    function movePlayer() {
      if (player.target) {
        const dx = player.target.x - player.x;
        const dy = player.target.y - player.y;
        const angle = Math.atan2(dy, dx);
        const vx = Math.cos(angle) * player.speed;
        const vy = Math.sin(angle) * player.speed;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < player.speed) {
          player.x = player.target.x;
          player.y = player.target.y;
          player.target = null;
        } else {
          player.x += vx;
          player.y += vy;
        }
      }

      // Keep player within bounds
      player.y = Math.max(playableTop + player.radius, Math.min(playableBottom - player.radius, player.y));
      player.x = Math.max(player.radius, Math.min(width - player.radius, player.x));
    }

    function moveEnemies() {
      enemies.forEach(enemy => {
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const angle = Math.atan2(dy, dx);
        enemy.x += Math.cos(angle) * enemy.speed;
        enemy.y += Math.sin(angle) * enemy.speed;

        // Keep enemies within bounds (optional)
        enemy.y = Math.max(playableTop + enemy.radius, Math.min(playableBottom - enemy.radius, enemy.y));
        enemy.x = Math.max(enemy.radius, Math.min(width - enemy.radius, enemy.x));
      });
    }

    function updateOrbs() {
      orbs.forEach(orb => {
        const dx = orb.x - player.x;
        const dy = orb.y - player.y;
        const angle = Math.atan2(dy, dx);
        const orbSpeed = 0.5 + (level - 1) * 0.1; // Increase orb speed with level
        orb.x += Math.cos(angle) * orbSpeed;
        orb.y += Math.sin(angle) * orbSpeed;

        // Keep orbs within bounds during movement
        orb.y = Math.max(playableTop + orb.radius, Math.min(playableBottom - orb.radius, orb.y));
        orb.x = Math.max(orb.radius, Math.min(width - orb.radius, orb.x));
      });
    }

    function checkCollisions() {
      // Orb collection
      for (let i = orbs.length - 1; i >= 0; i--) {
        const dx = player.x - orbs[i].x;
        const dy = player.y - orbs[i].y;
        const distSq = dx * dx + dy * dy;
        const radiiSumSq = (player.radius + orbs[i].radius) * (player.radius + orbs[i].radius);
        if (distSq < radiiSumSq) {
          coins += coinPerOrb;
          orbs.splice(i, 1);
          updateHUD();
        }
      }

      // Reset orbs if none are left
      if (orbs.length === 0) {
        subLevel++;
        coinPerOrb++;
        resetOrbs();
      }

      // Enemy collision
      for (let i = 0; i < enemies.length; i++) {
        const dx = player.x - enemies[i].x;
        const dy = player.y - enemies[i].y;
        const distSq = dx * dx + dy * dy;
        const radiiSumSq = (player.radius + enemies[i].radius) * (player.radius + enemies[i].radius);
        if (distSq < radiiSumSq) {
          if (player.hp > 0) {
            player.hp--;
            player.radius = Math.max(10, player.radius - 2); // Visually represent HP loss
          } else {
            coins = Math.max(0, coins - 5);
          }
          let newPos = {
            x: Math.random() * (width - 24) + 12,
            y: Math.random() * (playableBottom - playableTop - 24) + playableTop + 12
          };
          enemies[i].x = newPos.x;
          enemies[i].y = newPos.y;
          updateHUD();
        }
      }
    }

    function gameLoop() {
      ctx.clearRect(0, 0, width, height);

      // Draw player
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
      ctx.fill();

      // Draw enemies
      ctx.fillStyle = 'orange';
      enemies.forEach(enemy => {
        ctx.beginPath();
        ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
        ctx.fill();
      });

      // Draw orbs
      ctx.fillStyle = 'green';
      orbs.forEach(orb => {
        ctx.beginPath();
        ctx.arc(orb.x, orb.y, orb.radius, 0, Math.PI * 2);
        ctx.fill();
      });

      movePlayer();
      moveEnemies();
      updateOrbs();
      checkCollisions();

      requestAnimationFrame(gameLoop);
    }

    function handleInput(e) {
      const rect = canvas.getBoundingClientRect();
      player.target = {
        x: (e.clientX || e.touches[0].clientX) - rect.left,
        y: (e.clientY || e.touches[0].clientY) - rect.top
      };
    }

    window.addEventListener('resize', () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;

      // Recalculate playable area on resize
      const newHudHeight = hudElement.offsetHeight + 20;
      const newDockHeight = upgradeDockElement.offsetHeight + 10;
      playableTop = newHudHeight;
      playableBottom = height - newDockHeight;

      // Ensure player stays within new bounds
      player.y = Math.max(playableTop + player.radius, Math.min(playableBottom - player.radius, player.y));
      resetOrbs(); // Reset orb positions to be within new bounds
    });

    canvas.addEventListener('mousedown', handleInput);
    canvas.addEventListener('touchstart', handleInput);

    document.getElementById('speedUpgradeBtn').addEventListener('click', () => {
      if (coins >= speedUpgradeCost) {
        coins -= speedUpgradeCost;
        player.speed += 0.5;
        speedUpgradeCost = Math.round(speedUpgradeCost * 1.5);
        updateHUD();
      }
    });

    document.getElementById('sizeUpgradeBtn').addEventListener('click', () => {
      if (coins >= sizeUpgradeCost) {
        coins -= sizeUpgradeCost;
        player.radius += 2;
        player.hp++;
        player.maxHp++;
        sizeUpgradeCosts.push(Math.round(sizeUpgradeCost * 1.6));
        sizeUpgradeCost = sizeUpgradeCosts[sizeUpgradeCosts.length - 1];
        updateHUD();
      }
    });

    document.getElementById('levelUpBtn').addEventListener('click', () => {
      if (coins >= levelUpCost && level < 10) {
        coins -= levelUpCost;
        level++;
        subLevel = 1;
        coinPerOrb *= 2;
        createEnemy();
        levelUpCost = 20 * level;
        updateHUD();
      }
    });

    resetGame();
    gameLoop();
  </script>
</body>
</html>
